<!-- @format -->

// 装饰者模式可以动态地给【某个】对象添加一些【额外】的职责，而不会影响这个类中派生的其他对象

// 传统的 OOP 中，经常使用继承的方式来完成装饰者模式
// 缺点：1. 超类和子类的强耦合性，超类改变，子类也会改变
// 2. 继承这种功能复用方式经常被称为“白箱复用”，白箱的相对性是显而易见的，在继承的方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性
// 3. 装饰多种实例会产生大量的子类，不够灵活

// 所以需要一种可以【动态】增加职责的方式，也就是 decorator 装饰者模式

// 与代理模式不同的是 代理模式都是实现相同的功能
