<!-- @format -->

## 代际假说

将堆分为新生代与老生代分为两个区域

### 新生代：生成时间较短的对象(1-8M)

副垃圾回收器：Minor GC(Scavenger)，负责新生代的垃圾回收

#### Scavenge 算法

将新生区分为两部分：from-space/to-space

1. 新加入的对象都被放入 from-space，
2. 等区域快满的时候，会对内存区域中的对象做标记，将存活的对象复制到空闲区域，对象被有序排列起来，所以同时做了内存整理，复制后的空闲区域就没有内存碎片了
3. 角色翻转，form-space 变成 to-space，to-space 变成 from-space

#### 对象晋升策略

1. 经历过两次垃圾回收依然存活的对象会被移入老生区
2. 变量大小超过tospace的25%

### 老生代：生成时间久的对象

主垃圾回收器：Major GC，负责老生代的垃圾回收

#### 对象特点

1. 大对象
2. 存活时间长

#### Mark-Sweep 标记-清除算法

1. 标记阶段，从根元素开始遍历，能达到的对象活元素，没有到达的元素就为垃圾数据
2. 直接清除，导致产生大量的不连续内存碎片

#### Mark-Compact 标记-整理

标记可回收对象，将所有存货对象移到一端，直接清理掉剩余的内存

## 优化

问题：垃圾回收会占用主线程，可能会暂停造成画面卡顿

### 并行回收(副垃圾回收器)：

开启多个协助线程，并行清理
缺点：仍然是全暂停的

### 增量回收

将标记工作分解为更小的块，穿插在主线程不同任务之间完成，垃圾回收器没必要一次性完成工作，每次执行一部分即可
采用黑白灰标记法，其中黑色为存活节点，灰色为目前正在处理的节点，白色为垃圾对象

## 并发回收

回收线程执行 JS 过程中，辅助线程能够在后台执行垃圾回收操作

## 扩展
https://juejin.cn/post/6909239354418266119
https://segmentfault.com/a/1190000014383214
