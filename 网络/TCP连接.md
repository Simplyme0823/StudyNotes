<!-- @format -->

标志位，本质上就是数据表
SYN：Synchronize Sequence Numbers 同步序列号
ACK：Acknowledgement number 确认号

seq 就是初始化序列号 isn
状态
LISTEN:侦听 TCP 端口的连接请求(服务端监听)
SYN-SENT：发送请求后等待匹配的连接请求，(客户端发送了标志位)
SYN-RECEIVED：在接受和发送一个连接请求后等待对连接请求的确认
ESTABLISHED：代表一个打开的连接，数据可以传送给用户

三次握手----(两次确认)
第一次握手：客户端向服务端发送数据包，其中 SYN 标志位为 1，序列号为 J，并进入 SYN-SENT 状态
第二次握手：服务端接收到客户端的数据包，服务端会根据该数据包发送数据包，其中 ACK 标志位为 1，确认号为 J+1，SYN 标志位为 1，序列号为 K，服务器进入 SYN-RECEIVED 状态
第三次握手：客户端接受到服务端返回的数据包，向服务端发送数据包，其中 ACK 标志位为 1，确认号为 K+1，进入 ESTABLISHED 状态，服务器收到 ACK 标志位后，服务端进入连接已建立状态

/_第三次握手是可以携带数据的，前两次握手是不可以携带数据的_/

为什么要三次握手：(简洁版)

1. 防止重复历史链接的初始化导致问题(客户端连续发送多次 SYN 建立连接的报文)
2. 同步双方的初始序列号，序列号能够保证数据包不重复、不丢弃和按序传输。
3. 避免资源浪费
   「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
   「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

四次挥手
第一次挥手：客户端发送数据包 FIN 标志位为 1，顺序号为 u，客户端进入 FIN-WAIT-1 状态
第二次挥手：服务端接受数据包，返回 ACK 标志位为 1，确认号为 u+1，顺序号为 v 的数据包，并进入 CLOSE-WAIT 状态，客户端接受数据包后进入 FIN-WAIT-2 状态
第三次挥手：服务端发送数据包，FIN 标志位为 1，，顺序号为 w，ACK 标志位为 1，确认号为 u+1，服务端进入 LAST-ACK 状态
第四次挥手：客户端发送数据包，ACK 标志位为 1，顺序号为 u+1，确认号为 w+1，进入 TIME-WAIT 状态，等待 2MSL 事件，没有连接就关闭，服务端关闭
注意

为什么需要四次挥手

1. 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
2. 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

   https://www.jianshu.com/p/4ba0d706ee7c
   https://blog.csdn.net/gx17864373822/article/details/105531244
   为什么需要 LAST-ACK 状态：https://www.zhihu.com/question/27564314

为什么 TIME_WAIT 等待的时间是 2MSL？
MSL 是 Maximum Segment Lifetime，报文最大生存时间。网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

为什么需要 TIME_WATI

1. TCP 连接被复用，上一次连接传输的 ACK 包延迟到达，被客户端误接受了，导致数据错乱，所以需要 2MSL 时间来使得数据包在网络中自然消失
2. 如果最后一次挥手包丢失，那么服务端会重新发送一遍 FIN 包，如果 TIME_WAIT 过短导致重发后的 FIN 包不被接受，那么服务器会一直处于 LAST-ACK 状态，无法正确关闭

TIME_WAIT 过多危害：1. 内存占用； 2. 端口占用
